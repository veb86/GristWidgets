{== Исправление для uzvipcserver.pas ==

ЗАМЕНА функции ProcessClient (строка ~707)

Проблема: Команды добавляются в очередь IPCCommandQueue и ждут выполнения 
в главном потоке ZCAD, но ZCAD не вызывает IPCProcessPendingCommands.

Решение: Выполнять команды напрямую в потоке сервера (как временное решение).

== ИСПРАВЛЕННАЯ ВЕРСИЯ ProcessClient ==}

procedure TIPCServerThread.ProcessClient(ASocket: TSocket);
var
  Buffer: array[0..IPC_MAX_REQUEST_SIZE - 1] of Byte;
  BytesRead: Integer;
  RequestStr: string;
  Cmd: PIPCCommand;
  CmdResult: TIPCCommandResult;
  Response: TJSONObject;
  RequestCount: Integer;
begin
  Log('Client connected', LM_Info);
  RequestCount := 0;

  try
    {** Цикл обработки нескольких запросов в одном соединении }
    while FRunning do
    begin
      FillChar(Buffer, SizeOf(Buffer), 0);
      BytesRead := fpRecv(ASocket, @Buffer[0], SizeOf(Buffer) - 1, 0);

      if BytesRead <= 0 then
      begin
        Log('Client disconnected or error reading', LM_Info);
        Exit;
      end;

      SetString(RequestStr, PAnsiChar(@Buffer[0]), BytesRead);
      RequestStr := Trim(RequestStr);

      Log(Format('Received [%d]: %s', [RequestCount, RequestStr]), LM_Debug);

      {** Парсинг команды }
      if not ParseCommand(RequestStr, Cmd) then
      begin
        Response := CreateResponse('', 'error', '', 'Invalid request or token');
        SendResponse(ASocket, Response);
        Response.Free;
        Exit;
      end;

      try
        {** === ИСПРАВЛЕНИЕ: Выполняем команду напрямую в потоке сервера === }
        {** Вместо добавления в очередь и ожидания, выполняем сразу }
        
        IPCCommandQueue.SetStatus(csBusy);
        try
          {** Выполняем команду напрямую }
          CmdResult := ExecuteCommand(Cmd);
          
          {** Формируем ответ }
          Response := CreateResponse(Cmd^.ID, CmdResult.Status, 
            CmdResult.Result, CmdResult.Error);
          Cmd^.Response := Response;
          
        finally
          IPCCommandQueue.SetStatus(csIdle);
        end;

        {** Отправляем ответ }
        if Cmd^.Response <> nil then
        begin
          SendResponse(ASocket, Cmd^.Response);
        end
        else
        begin
          CmdResult.Status := 'error';
          CmdResult.Error := 'Command execution error';
          Response := CreateResponse(Cmd^.ID, CmdResult.Status, 
            CmdResult.Result, CmdResult.Error);
          SendResponse(ASocket, Response);
          Response.Free;
        end;
        {** ============================================================ }
        
      finally
        {** Очистка }
        if Cmd^.Response <> nil then
          Cmd^.Response.Free;
        if Cmd^.Args <> nil then
          Cmd^.Args.Free;
        Cmd^.Completed.Free;
        Dispose(Cmd);
      end;

      Inc(RequestCount);
      Log(Format('Request %d processed', [RequestCount]), LM_Debug);
    end;

  except
    on E: Exception do
    begin
      Log(Format('Error processing client: %s', [E.Message]), LM_Error);
      try
        Response := CreateResponse('', 'error', '', E.Message);
        SendResponse(ASocket, Response);
        Response.Free;
      except
      end;
    end;
  end;

  {** Закрытие соединения с клиентом }
  CloseSocket(ASocket);
  Log('Client connection closed', LM_Info);
end;

{== КОНЕЦ ИСПРАВЛЕНИЯ ==}
